---

![](https://www.fastradius.com/assets/uploads/heroes/FastRadius_018_resized.jpg)

---

# The __Factory__ of the __Future__

### Clark Kampfe

![](https://www.fastradius.com/assets/uploads/heroes/FastRadius_018_resized.jpg)

---

# talk goals

- history
- experiences
- reflections


![](https://www.fastradius.com/assets/uploads/heroes/FastRadius_018_resized.jpg)

---

# Fast Radius

- Production-quality 3D printing manufacturing
- Chicago
- 50 people
- 3 devs
- Elixir

![](https://www.fastradius.com/assets/uploads/heroes/FastRadius_018_resized.jpg)


---

<!-- MILL -->

## Manufacturing 

^Manufacturing is not just technology, but, crucially, process

^Manufacturing and information have been linked right from the get go.

^Mill, UK, 14th century, Flour

![](https://upload.wikimedia.org/wikipedia/commons/6/66/WaterMill_Interior_MotionBlur.jpg)


---

![](/Users/clark/Downloads/volvo-skovde-plant-1.jpg)

---

## Produce
- Latin: 'pro' - 'ducere': "forward, to lead"
- create or form (something) as part of a physical, biological, or chemical process

![](https://upload.wikimedia.org/wikipedia/commons/1/1b/The_Caxton_Celebration_-_William_Caxton_showing_specimens_of_his_printing_to_King_Edward_IV_and_his_Queen.jpg)


---

^Cuneiform. Writing.

^An account of barley rations issued monthly to adults and children written in cuneiform script on a clay tablet, written in year 4 of King Urukagina, c. 2350 BC

![](/Users/clark/Downloads/Issue_of_barley_rations.JPG)


---

^Interchangeable parts - Late 1700s

^Jean-Baptiste Vaquette de Gribeauval

^French General,

^Honore Blanc

^COMPARISON AGAINST A MASTER

^Software people might know this as testing

^Standards, Measuring, QA, inventory

![](/Users/clark/Downloads/Gribeauval_system_elements.jpg)

---

^Steam Engine

^Early 1700s

^Massive efficiency
^Could run all the time
^Wouldn't get tired like a horse

![](https://upload.wikimedia.org/wikipedia/commons/0/0f/Jacob_Leupold_Steam_engine_1720.jpg)

---

^Log table
^For engineering, statistics, shipping/navigation

![](/Users/clark/Downloads/Logarithmorum_Chilias_Prima_page_0-67.jpg)

---

^Charles Babbage

^Analytical engine

![](/Users/clark/Downloads/Charles_Babbage_by_Antoine_Claudet_c1847-51-crop.jpg)
![](/Users/clark/Downloads/medium_1878_0003__0001_.jpg)

---

^Ada Lovelace
^First programmer, wrote a program to calculate the sequence of Bernoulli numbers
^Which are a sequence of rationals that are negative if N is divisible by 4 and positive otherwise

^Project was scrapped when Babbage died!

![](/Users/clark/Downloads/Ada_Byron_daguerreotype_by_Antoine_Claudet_1843_or_1850.jpg)

---

^Lovelace's "Note G", the first program ever written, to calculate a series of the Bernoulli Numbers
^Unfortunately the machine for which she wrote the program was never built, so she never got to run the program.
^In this way, having had her project canned before completion, she really is the first programmer.

![](/Users/clark/Downloads/Diagram_for_the_computation_of_Bernoulli_numbers copy.jpg)

---

^B-24 Liberators at a plant in Texas

^Major innovations in all kinds of technology: aviation, transportation, weapons, etc.

![](/Users/clark/Downloads/pic_giant_051415_SM_B-24-Liberator-Plant-2.jpg)


---

^Alan Turing

^Cracked the Engima

^Invented the modern model of computation

![](/Users/clark/Downloads/1*FCZMG2AgKPDXqXyOtV4faA.png)

---

^1960s/1970s

![](/Users/clark/Downloads/Arpanet-1972-Map.png)

---

^Reprap

^You may know 3D printing, but if you don't
^3D printing is manufacturing by the precise addition of raw material to form a solid
^This is in contrast to subtractive manufacturing, like woodworking, machining, milling, etc.

![](https://upload.wikimedia.org/wikipedia/commons/f/f2/Reprap_at_Metalab.jpg)


---

^3D printing is a fairly recent technology
^The patents for FDM (fused deposition modeling) only expired in 2009
^This led to an explosion of activity in the space, with 3D printing becoming something you could go out and buy for a few hundred dollars rather than as a some kind of Star-Trek fantasy
^I think a lot of people have this image of 3D printing in their head as a prototype technology. Sure it's fast and convenient, but the quality is low.

![](https://upload.wikimedia.org/wikipedia/commons/a/a3/Witten_Zentralbibliothek_Makerbot_Replicator.jpg)

---

^This is has been true until recently.
^There has been a generational advancement in 3D printing tech, where the consistency of the print and, crucially, the engineering properties of the parts has reached levels demanded by mass-market equipment manurfacturers.
^This means parts strong enough to put in a car, in a plane, in your teeth, in your hip, in your kitchen. Anywhere you can think.

![](/Users/clark/Downloads/Daniel.jpg)


---

^Charlie

^Ok so the parts are better, what does that mean practically.
^1. You can produce things that were impossible to build. Like, lattices, hollow things, things that required a lot of assembly can be printed as one piece.
^2. This changes everything, logistically.

![](/Users/clark/Downloads/Design.jpg)

--- 

![](/Users/clark/Downloads/maxresdefault.jpg)

^3. Think, for a second, about how much stuff you order on Amazon.
^Think about where that stuff is, before it gets to you.
^Think about how long it sits there. Think about how many trucks it rides on. Planes. Ships.
^Now, imagine what would happen if instead of warehousing all of that stuff, we could build it as soon as you ordered it. At a location near you. Imagine what that does for delivery times. Imagine how much that saves on warehousing. Shipping. Carbon emissions from shipping overseas and in flight. How much this can clean up supply chains.

^3D printing is a manufacturing technology, and it will greatly improve the parts we use in our everyday stuff. But in some ways its an supply chain technology. It's an information technology.

^End to end production factory

^From sale to design to production, QA, fulfillment, reorder, everything

^This is a huge deal, but it's not quite a reality yet. 

^Why not?



---

^Alan Kay in his Turing award lecture has this point about 30 year lags from when an idea was
^generally proved out to when it was generally accepted. And really, this point speaks to fashion, and the social phenomena around what it takes for things to go mainstream. We've seen it with all kinds of things. Cell phones. Getting rid of cable. Owning a car. Being alright with getting in a stranger's car as if it were a taxi.

> in computing, there are many, many instances of roughly 30-year lags from when an idea was really proved out to when it gets generally accepted
-- Alan Kay, Turing Award lecture

^But we know another technology kind of like this.

---

^3D printing: 1986, 1987
^Erlang: mid to late 80s


^Left is the first photopolymer SLA printer, the SLA-1
^Right is the first Erlang interpreter

^And it's going to take a huge improvement in the constellation of information technologies around it, in order to manage and make best use of its unique ability to create something out of thin air.


![](/Users/clark/Desktop/Screen Shot 2019-02-27 at 11.22.16 PM.png)
![](/Users/clark/Downloads/erlang-1.jpg)

---

^SEGUE INTO WHY ELIXIR

^Elixir and 3D printing seem unusually suited to each other.
^They're both a radically reimagined way to of modeling the world, of thinking about how you build things.
^They both are making us question conventional thinking about how you build things.
^Do I need a cache for this? or is my app fast enough
^Why do I need to wait 2 months for the first sample parts from our overseas injection molding shop
^I should be able to quickly adapt my designs to meet new requirements
^I should be able to understand my systems, physical or virtual, in precise detail


^Elixir Logo

![](/Users/clark/Downloads/1*wVcT8A29lBkN0gXFPJUF3w copy.png)

---

## Process
- 'pro' - 'cedere': "forward, to go"
- a series of actions or steps taken in order to achieve a particular end

![](https://upload.wikimedia.org/wikipedia/commons/1/1b/The_Caxton_Celebration_-_William_Caxton_showing_specimens_of_his_printing_to_King_Edward_IV_and_his_Queen.jpg)

^We're trying to be a business.

^We're trying to prove that our product, production-quality additive parts, is something people want

^We're also trying to run a business, which has a lot of moving parts to it other than pure delivery

^You have to be able to take orders, modify them, produce them, QA them, ship them, etc.

^And, crucially, you have to be able to adapt your process along the way. You rely on a lot of faulty assumptions, and you have to adjust your response as you learn why your assumptions were incorrect. 

^This isn't like cracking a safe, where if you get the code, you win the business.

^Innovation, it turns out, is really messy. It's really messy, and you are desperately searching, grasping even, for things that give you leverage and help you focus on what you want to improve, by helping you not care about the stuff you don't want to care about.

---

^PHOENIX

^So, like many of you, the core of our deployment is a phoenix app.
^It really is central to what we do.
^It helps us make sales, take orders, schedule and dispatch work, monitor the our factory floor, and ultimately get production-grade parts into the hands of customers.
^We all depend on it to be rock solid, and it is. It sounds weird to say this, but we've had no issues with Phoenix. It pretty much just works. It's kind of alarming in some ways, because we know when something isn't working that there is nearly a 100% chance that it's a bug we wrote in our code!
^And on top of the reliability, it's fast as hell. Our users love that.
^We have about 300 tests or so, including integration, and they run in a couple of seconds. And they scale with our hardware, so they absolutely fly on my 6-core machine. It's great to get this kind of quality-of-life stuff essentially for free.

![](/Users/clark/Downloads/1*THRh4--2uAqVuBM_Iab78A.png)

---

^A lot of our work looks like this
^The Elixir work, not the printing production work, I should be clear. The parts of more sophisticated :)
^Left, is a 3D model of the Toy Story alien
^Right is a screenshot of the same model, for presentation on the web

![](/Users/clark/Desktop/Screen Shot 2019-02-27 at 9.39.37 PM.png)
![](/Users/clark/Downloads/VmmFqBG8_aSCrHzv8LeR.png)

---

^It actually is a lot of these things

- screenshot thumbnail generation
- pdf creation
- part complexity calculation
- 3rd party API token refresh
- mesh simplification
- file upload

^And, Elixir and Phoenix don't actually do these. Not directly.
^Some of this work is using some open source packages, like openscad or wkhtmltopdf
^Some is over a network, dealing with flakey 3rd party APIs
^Some of it is dealing with raw customer data, tagging it, and storing it so it's useful

^And I didn't expect this at first, but, a lot of this work can be performed in an idempotent way. That is, if it runs more than once of a given set of inputs, the result doesn't change.
^This is huge, because this has allowed us to lean heavily on Elixir and OTP to handle transient failures for us.
^And there are plenty of transient failures, this is the real world.
^APIs go down, users upload strange files, tokens expire, and, of course, PDF generation is its own fun-house of random failure.


![](/Users/clark/Desktop/Screen Shot 2019-02-27 at 9.39.37 PM.png)
![](/Users/clark/Downloads/VmmFqBG8_aSCrHzv8LeR.png)

---

^Again, having this stuff be idempotent has allowed us to write stuff in such a way that we have really cut down on our architectural complexity. We try to explicitly separate the function of "finding work to do" from the function of "doing that work".
^And because this stuff is relatively idempotent, the callgraph is roughly this simple.
^Something finds work, and passes it off to something else, in a separate process.
^Neither one of those processes care about the other, they are unlinked, they can't crash each other, and supervision ensures that they are both up and ready to accept work.

^This stuff is really in service of our users. That's who we want to see succeed.
^When the folks on the factory floor are happy, and when the mechanical engineers are happy, and when our paying customer are happy, we're happy.
^This is a really longwinded way of saying that Phoenix and Elixir and OTP have really helped us delegate a lot of this architectural stuff, so we can focus on what is going to best help the folks doing the heavy lifting.

```
           +-----------------+               
           |                 |               
           |                 |               
           |some supervision |               
           |    hierarchy    |               
           |                 |               
           |                 |               
           +-----------------+               
                    |                        
       +------------|--------------+         
       |                           |         
       v                           v         
+------------+           +------------------+
|            |           |                  |
|            |           |                  |
| find work  |---------->|     do work      |
|            |           |                  |
|            |           |                  |
+------------+           +------------------+
```

---

^I'll give you an example.

^We have an internal concept of a work order.
^When a customer places an order with us, we accept that order, store all of the data,
^and then schedule that work to be produced.
^Some orders are huge, and so they can't all be printed as part of the same physical print.
^The entity that describes what actually ends up on the build plate of a given printer is what we call a "work order".
^What materials, what parts, when it's due, who is handling the print, what post-production it needs, etc.
^As you might imagine, work orders change. Materials change, printer availability changes, delivery dates change, the works.
^It's crucial that everyone in our organization be on the same page about a given work order, so we deliver the fastest, best quality part we possibly can.
^So, we used phoenix channels to push updates in real time.
^Whether you're a mechanical engineer putting the finishing touches on a design, or a lab technician actually producing the real print, you will see a real-time update. You stop worrying about stale data.
^It's been amazingly reliable
^And, the barrier to entry for doing this was not much more code that what you see on this slide. It's helped us improve our delivery performance and make sure everyone is on the same page for crucial information.

```elixir
# Someone modified the work order
|> Ecto.Multi.run(:work_order, fn _repo, %{changeset: changeset} ->
  changeset
  |> Repo.update()
  |> case do
    {:ok, work_order} ->
      work_order = get_work_order!(work_order.id)

      # render notification view
      json =
        FastRadiusWeb.Api.V1.WorkOrderView.render("work_order.json", %{work_order: work_order})

      # send channel update
      FastRadiusWeb.Endpoint.broadcast("refresh:all", "refresh", %{
        "data" => json
      })

     error ->
       error
    end
end)
# ...
```

---

^Phoenix is amazing. We really love it.
^But Elixir and OTP has also proven really versatile.
^There's quite a bit of Nerves at the conference this year, and that's amazing.
^We're certainly not the first or only people doing Nerves, but we are doing it, and we love it, so I'll pile on with how it's been useful for us.

^Our core competency is not embedded hardware.
^We're building that competency, but we wanted to avoid printing our own circuit boards or writing embedded C code if at all possible. Mostly, this is a time concern.
^And nerves has let us quickly and, I'll say, fairly easily get useful, robust things up and going.

^One of the headaches when doing embedded development, as I've discovered, is the iteration cycle.
^How do you get firmware onto the device? How do you configure it? How do you debug it?
^Once you've done that, how do you verify that your business logic is correct?

![](/Users/clark/Downloads/rpi.jpg)
![](/Users/clark/Downloads/si7021.jpg)

---

^So, we took a page out of the old Lisp playbook and thought "code really is just data. let's send code to the device, let's develop right on the device".
^So, how do we do this?
^Well, we leaned on the community. Paul Schoenfelder, and contributors, have written this amazing libcluster library, that helps you do ad-hoc clustering of BEAM nodes.
^So we set up libcluster to do discovery over UDP multicast, and configure that on the remote device and on a project local on my laptop.

^libcluster

![](/Users/clark/Desktop/Screen Shot 2019-02-26 at 11.58.23 AM.png)

--- 

^Once that's set up and running, you have this cluster of devices on your network that all are sort of reaching out and saying hello to each other.
^You can get their IPs and hosts without setting up any sort of elaborate node management stuff.
^It's very easy
^Then, we run a command like this our local machine.
^The most relevant bits here are on the last line, which tells the BEAM on my laptop to open up a an iex shell on the remote node, and to start observer.

```sh
$ iex --name me \
      --cookie YOUR_COOKIE_HERE \
      --remsh rasppi@192.168.10.10 -e ":observer.start()"
```

---

^So this is pretty amazing, for almost no work.
^Live console on the Pi!
^See debugging stuff!
^Run commands, see if stuff is actually happening like you thought it was.
^This for us has been crucial to actually getting things right. Hardware is hard, and
^we've found, the more interactive it is, the less frustrating it is.

![](/Users/clark/Desktop/Screen Shot 2019-02-26 at 12.16.38 PM.png)

---


^Observer on the Pi
^View load
^See IO

![](/Users/clark/Desktop/Screen Shot 2019-02-26 at 12.16.53 PM.png)

---

^But, we don't stop there.
^I was tooling around one day in the Erlang docs and found the Erlang version of this snippet.
^This code lets you first, write your code on your local machine, like usual you can run tests, run that code with debug flags, whatever you want
^Then, when you're ready, you can whisk it off to your hardware development device, your rasp pi
^And remember, we have our remote shell open to the embedded hardware device, so you can now play around with that code on the native hardware, with your peripherals attached, and everything else
^Of course this doesn't invalidate any of the built-in Nerves firmware deployment architecture, which works very well. It complements it, for when you want a tight iteration cycle when you're exploring, trying to figure out an integration, or why something works on your local machine but not on the remote machine.

```elixir
# get the freshest compiled code
iex> recompile

# find object code for module `mod`
iex> {mod, bin, file} = :code.get_object_code(mod)

# load it on all nodes in the cluster
iex> {result, _} = :rpc.multicall(:code, :load_binary, [mod, file, bin])
```

---
^In fact we used it to figure out a temperature/humidity sensor integration.
^It's great to be able to read specs, and how things say they'll operate, but once you have things wired up and you're pretty confident of your wiring, you want to get on the device and figure out why it keeps crashing

- nerves
- libcluster
- https://github.com/fhunleth/elixir_ale
- erlang/otp

![](/Users/clark/Desktop/Screen Shot 2019-02-26 at 11.50.16 AM.png)


---


^TODO needs pic

# __OTP__


## You still have to design

^You still have to do design work.
^You still have to understand OTP
^This is real work
^If you use OTP wrong, it can hurt you

---

# Elixir does __not__ do everything

^you want a constrained system. you do not want a system that does everything

^it does serve amazingly well as a control plane

^This reflects its designed nature. It was made for a problem,
^rather than, as Alan Kay likes to say, "inverse vandalsim", because we could

---

# The __Factory__ of the __Future__

### @clarkkampfe

![](https://www.fastradius.com/assets/uploads/heroes/FastRadius_018_resized.jpg)
